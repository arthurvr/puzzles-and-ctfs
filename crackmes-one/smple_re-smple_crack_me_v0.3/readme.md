# simple_re's smple_crack_me_v3.0

*[Link](https://crackmes.one/crackme/5ab77f6333c5d40ad448ca2f)*

## Solution

### 1. Defeating the anti-debugger checks

There's some anti-debugger methods in use on the executable. I started by building a patched version of the program that disables those.

The present anti-debugger techniques I could find are:

* The typical [IsDebuggerPresent](https://stackoverflow.com/questions/10330147/how-do-i-bypass-isdebuggerpresent-with-ollydbg) one.
* This [ProcessDebugPort](https://anti-debug.checkpoint.com/techniques/debug-flags.html#using-win32-api-ntqueryinformationprocess-processdebugport) trick.
* The executable tries to exploit a known vulnerability in OllyDbg, a [string format vulnerability](https://vuldb.com/?id.21973). I don't use OllyDbg so didn't patch this one. It's a good trick to know though, and very recognisable by all the calls to `CrashOlly(void)`.
* There's a timing check (search for `GetTickCount` to find it) which checks if the program is taking longer than usual. This one was so buggy I even had to disable it to use the program outside of a debugger. Disabling this is as easy as patching a conditional jump to a normal `jmp` one. 

See the links for more information and the typical patch. Usually patching is as easy as changing a jump instruction.

I hope I found them all -- at least I didn't have any trouble using IDA on Windows 8.1 after these patches.

### 2. Valid name/serial

I switched between the assembly view and the pseudocode generated by IDA, depending on what's the most readable. This way I found various conditions the name/serial combination must satisfy.

First the length of the given name is saved to `[ebp+var_29C]`, and later there's a check to see if it is more than 3 characters:

![](https://i.imgur.com/gBS4tjy.png)

![](https://i.imgur.com/nelyXTs.png)

There's later also a check to see if it's less than or equal to 6 characters.

![](https://i.imgur.com/GBHcypA.png)

Now, there's this piece of code. The last character of the serial must be first character of the hostname.

![](https://i.imgur.com/bzSmbe2.png)

And the first character of the serial must be the third of the mac-address:

![](https://i.imgur.com/ZWgIDAf.png)

And the second character of the serial must be second character of the IP address.

![](https://i.imgur.com/yWkIhhK.png)

Now, for the remaining of the serial code. First, this function called `CreateSerialFromName` function, which converts the given name to an ASCII string representation:

![](https://i.imgur.com/SfI9mpj.png)

The result of this is used in `GetFinalSerialFromHexedName()`. I have no idea if the calculation in this function has any meaning, but it looks easy to replicate in python.

![](https://i.imgur.com/DAFb9uo.png)

### 3. Keygen

I can get the hostname, IP, MAC address, ... in a Python script, and I can also replicate that last calculation on the name. So I did this in `keygen.py`, and looks like it works:

![](https://i.imgur.com/UGhg8Tq.png)

![](https://i.imgur.com/pOvybV7.png)

There's a name hardcoded in the keygen for now, but that's easy to change.

